// THIS FILE WAS GENERATED BY `xtp-zig-bindgen`. DO NOT EDIT.
const std = @import("std");
const extism = @import("extism-pdk");

const _host = struct {
    extern "extism:host/user" fn react(u64) u64;
    extern "extism:host/user" fn request(u64) u64;
    extern "extism:host/user" fn sendMessage(u64) u64;
    extern "extism:host/user" fn watchMessage(u64) u64;
};

const _plugin = extism.Plugin.init(std.heap.wasm_allocator);

/// Host contains all of the provided import functions made available to
/// plugins by the host platform where your plugin will run.
pub const Host = struct {
    ///
    /// It takes input of OutgoingReaction (send a reaction)
    /// And it returns an output HandlerResult (A result.)
    pub fn react(input: OutgoingReaction) !HandlerResult {
        const b = try std.json.stringifyAlloc(_plugin.allocator, input, .{});
        const inMem = _plugin.allocateBytes(b);
        if (inMem.offset == 0) {
            return error.ExtismBadMemory;
        }
        defer inMem.free();

        const ptr = _host.react(inMem.offset);
        if (ptr == 0) {
            return error.ExtismBadMemory;
        }
        const outMem = _plugin.findMemory(ptr);
        defer outMem.free();
        const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        const out = try std.json.parseFromSlice(HandlerResult, _plugin.allocator, buffer, .{ .allocate = .alloc_always, .ignore_unknown_fields = true });
        return out.value;
    }

    ///
    /// It takes input of OutgoingRequest (An HTTP request)
    /// And it returns an output HandlerResult (A result.)
    pub fn request(input: OutgoingRequest) !HandlerResult {
        const b = try std.json.stringifyAlloc(_plugin.allocator, input, .{});
        const inMem = _plugin.allocateBytes(b);
        if (inMem.offset == 0) {
            return error.ExtismBadMemory;
        }
        defer inMem.free();

        const ptr = _host.request(inMem.offset);
        if (ptr == 0) {
            return error.ExtismBadMemory;
        }
        const outMem = _plugin.findMemory(ptr);
        defer outMem.free();
        const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        const out = try std.json.parseFromSlice(HandlerResult, _plugin.allocator, buffer, .{ .allocate = .alloc_always, .ignore_unknown_fields = true });
        return out.value;
    }

    ///
    /// It takes input of OutgoingMessage (An outgoing message)
    /// And it returns an output HandlerResult (A result.)
    pub fn sendMessage(input: OutgoingMessage) !HandlerResult {
        const b = try std.json.stringifyAlloc(_plugin.allocator, input, .{});
        const inMem = _plugin.allocateBytes(b);
        if (inMem.offset == 0) {
            return error.ExtismBadMemory;
        }
        defer inMem.free();

        const ptr = _host.sendMessage(inMem.offset);
        if (ptr == 0) {
            return error.ExtismBadMemory;
        }
        const outMem = _plugin.findMemory(ptr);
        defer outMem.free();
        const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        const out = try std.json.parseFromSlice(HandlerResult, _plugin.allocator, buffer, .{ .allocate = .alloc_always, .ignore_unknown_fields = true });
        return out.value;
    }

    ///
    /// It takes input of []const u8 (the id of a message to watch)
    /// And it returns an output HandlerResult (A result.)
    pub fn watchMessage(input: []const u8) !HandlerResult {
        const inMem = _plugin.allocateBytes(input);
        if (inMem.offset == 0) {
            return error.ExtismBadMemory;
        }
        defer inMem.free();

        const ptr = _host.watchMessage(inMem.offset);
        if (ptr == 0) {
            return error.ExtismBadMemory;
        }
        const outMem = _plugin.findMemory(ptr);
        defer outMem.free();
        const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        const out = try std.json.parseFromSlice(HandlerResult, _plugin.allocator, buffer, .{ .allocate = .alloc_always, .ignore_unknown_fields = true });
        return out.value;
    }
};

/// An emoji used to react
pub const Emoji = struct {
    /// whether or not the emoji is animated
    animated: bool,
    /// The id of the reaction (if custom); null if a built-in emoji
    id: ?[]const u8 = null,
    /// the name used for the reactji; built-in emoji will be the literal character, otherwise the text name appears here
    name: []const u8,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *Emoji) !*Emoji {
        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *Emoji) !*Emoji {
        return self;
    }
};

/// A result.
pub const HandlerResult = struct {
    /// An error code. Zero indicates success. Negative numbers indicate failure.
    errorCode: i64,
    /// An id for the result
    id: ?[]const u8 = null,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *HandlerResult) !*HandlerResult {
        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *HandlerResult) !*HandlerResult {
        return self;
    }
};

/// An incoming event
pub const IncomingEvent = struct {
    /// The channel the message was received in
    channel: []const u8,
    /// The guild the message was received in
    guild: []const u8,
    /// The kind of event (one of "content", "watch:reference", "watch:reaction:added", "watch:reaction:removed", "http:response")
    kind: []const u8,
    /// An incoming message
    message: ?IncomingMessage = null,
    /// A reaction happened
    reaction: ?IncomingReaction = null,
    /// We received a response
    response: ?IncomingResponse = null,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *IncomingEvent) !*IncomingEvent {
        if (self.message != null) {
            self.message = (try self.message.?.XXX__decodeBase64Fields()).*;
        }

        if (self.reaction != null) {
            self.reaction = (try self.reaction.?.XXX__decodeBase64Fields()).*;
        }

        if (self.response != null) {
            self.response = (try self.response.?.XXX__decodeBase64Fields()).*;
        }

        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *IncomingEvent) !*IncomingEvent {
        if (self.message != null) {
            self.message = (try self.message.?.XXX__encodeBase64Fields()).*;
        }

        if (self.reaction != null) {
            self.reaction = (try self.reaction.?.XXX__encodeBase64Fields()).*;
        }

        if (self.response != null) {
            self.response = (try self.response.?.XXX__encodeBase64Fields()).*;
        }

        return self;
    }
};

/// An incoming message
pub const IncomingMessage = struct {
    /// The username of the author of the message
    author: []const u8,
    /// The message text
    content: []const u8,
    /// An id identifying the message.
    id: []const u8,
    /// The id of the message to which this message replies
    reference: ?[]const u8 = null,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *IncomingMessage) !*IncomingMessage {
        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *IncomingMessage) !*IncomingMessage {
        return self;
    }
};

/// A reaction happened
pub const IncomingReaction = struct {
    /// The username that reacted
    from: []const u8,
    /// An incoming message
    message: IncomingMessage,
    /// An emoji used to react
    with: Emoji,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *IncomingReaction) !*IncomingReaction {
        self.message = (try self.message.XXX__decodeBase64Fields()).*;

        self.with = (try self.with.XXX__decodeBase64Fields()).*;

        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *IncomingReaction) !*IncomingReaction {
        self.message = (try self.message.XXX__encodeBase64Fields()).*;

        self.with = (try self.with.XXX__encodeBase64Fields()).*;

        return self;
    }
};

/// We received a response
pub const IncomingResponse = struct {
    /// the http body
    body: []const u8,
    /// the http headers
    headers: std.json.ArrayHashMap(std.json.Value),
    /// the identifier the plugin sent
    id: []const u8,
    /// the http status code
    status: i64,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *IncomingResponse) !*IncomingResponse {
        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *IncomingResponse) !*IncomingResponse {
        return self;
    }
};

/// An outgoing message
pub const OutgoingMessage = struct {
    /// The channel the message was received in
    channel: ?[]const u8 = null,
    /// The message text
    message: []const u8,
    /// A message ID to reply to
    reply: ?[]const u8 = null,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *OutgoingMessage) !*OutgoingMessage {
        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *OutgoingMessage) !*OutgoingMessage {
        return self;
    }
};

/// send a reaction
pub const OutgoingReaction = struct {
    /// the message id
    messageId: []const u8,
    /// The emoji reaction
    with: []const u8,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *OutgoingReaction) !*OutgoingReaction {
        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *OutgoingReaction) !*OutgoingReaction {
        return self;
    }
};

/// An HTTP request
pub const OutgoingRequest = struct {
    /// the http body
    body: []const u8,
    /// the http headers
    headers: std.json.ArrayHashMap(std.json.Value),
    /// the http method
    method: []const u8,
    /// the url
    url: []const u8,

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__decodeBase64Fields(self: *OutgoingRequest) !*OutgoingRequest {
        return self;
    }

    /// Internally used function, should not be called by plugin authors.
    pub fn XXX__encodeBase64Fields(self: *OutgoingRequest) !*OutgoingRequest {
        return self;
    }
};
