// THIS FILE WAS GENERATED BY `xtp-rust-bindgen`. DO NOT EDIT.

#![allow(unused_macros)]
#![allow(non_snake_case)]
use extism_pdk::*;
use serde::{Deserialize, Serialize};

fn return_error(e: Error) -> i32 {
    let err = format!("{:?}", e);
    let mem = extism_pdk::Memory::from_bytes(&err).unwrap();
    unsafe {
        extism_pdk::extism::error_set(mem.offset());
    }
    -1
}

macro_rules! try_input {
    () => {{
        let x = input();
        match x {
            Ok(x) => x,
            Err(e) => return return_error(e),
        }
    }};
}

macro_rules! try_input_json {
    () => {{
        let x = input();
        match x {
            Ok(Json(x)) => x,
            Err(e) => return return_error(e),
        }
    }};
}

use base64_serde::base64_serde_type;

base64_serde_type!(Base64Standard, base64::engine::general_purpose::STANDARD);

#[no_mangle]
pub extern "C" fn handle() -> i32 {
    let ret = crate::handle(try_input_json!()).and_then(output);

    match ret {
        Ok(()) => 0,
        Err(e) => return_error(e),
    }
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct Emoji {
    // whether or not the emoji is animated
    #[serde(rename = "animated")]
    pub animated: Option<bool>,
    // The id of the reaction (if custom); null if a built-in emoji
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: Option<String>,
    // the name used for the reactji; built-in emoji will be the literal character, otherwise the text name appears here
    #[serde(rename = "name")]
    pub name: String,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct HandlerResult {
    // An error code. Zero indicates success. Negative numbers indicate failure.
    #[serde(rename = "errorCode")]
    pub error_code: i64,
    // An id for the result
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: Option<String>,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct IncomingEvent {
    // The channel the message was received in
    #[serde(rename = "channel")]
    pub channel: String,
    // The guild the message was received in
    #[serde(rename = "guild")]
    pub guild: String,
    // The kind of event (one of "content", "watch:reference", "watch:reaction:added", "watch:reaction:removed", "http:response")
    #[serde(rename = "kind")]
    pub kind: String,
    // An incoming message
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: Option<IncomingMessage>,
    // A reaction happened
    #[serde(rename = "reaction")]
    #[serde(default)]
    pub reaction: Option<IncomingReaction>,
    // We received a response
    #[serde(rename = "response")]
    #[serde(default)]
    pub response: Option<IncomingResponse>,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct IncomingMessage {
    // The username of the author of the message
    #[serde(rename = "author")]
    pub author: String,
    // The message text
    #[serde(rename = "content")]
    pub content: String,
    // An id identifying the message.
    #[serde(rename = "id")]
    pub id: String,
    // The id of the message to which this message replies
    #[serde(rename = "reference")]
    #[serde(default)]
    pub reference: Option<String>,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct IncomingReaction {
    // The username that reacted
    #[serde(rename = "from")]
    pub from: String,
    // An incoming message
    #[serde(rename = "message")]
    pub message: IncomingMessage,
    // An emoji used to react
    #[serde(rename = "with")]
    pub with: Emoji,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct IncomingResponse {
    // the http body
    #[serde(rename = "body")]
    pub body: String,
    // the http headers
    #[serde(rename = "headers")]
    pub headers: std::collections::HashMap<String, serde_json::Value>,
    // the identifier the plugin sent
    #[serde(rename = "id")]
    pub id: String,
    // the http status code
    #[serde(rename = "status")]
    pub status: i64,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct OutgoingMessage {
    // The channel the message was received in
    #[serde(rename = "channel")]
    #[serde(default)]
    pub channel: Option<String>,
    // The message text
    #[serde(rename = "message")]
    pub message: String,
    // A message ID to reply to
    #[serde(rename = "reply")]
    #[serde(default)]
    pub reply: Option<String>,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct OutgoingReaction {
    // the message id
    #[serde(rename = "messageId")]
    pub message_id: String,
    // The emoji reaction
    #[serde(rename = "with")]
    pub with: String,
}

#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct OutgoingRequest {
    // the http body
    #[serde(rename = "body")]
    pub body: String,
    // the http headers
    #[serde(rename = "headers")]
    pub headers: std::collections::HashMap<String, serde_json::Value>,
    // the http method
    #[serde(rename = "method")]
    pub method: String,
    // the url
    #[serde(rename = "url")]
    pub url: String,
}

mod raw_imports {
    use super::*;
    #[host_fn]
    extern "ExtismHost" {

        pub(crate) fn react(input: Json<OutgoingReaction>) -> Json<HandlerResult>;

        pub(crate) fn request(input: Json<OutgoingRequest>) -> Json<HandlerResult>;

        pub(crate) fn sendMessage(input: Json<OutgoingMessage>) -> Json<HandlerResult>;

        pub(crate) fn watchMessage(input: String) -> Json<HandlerResult>;

    }
}

// react
// It takes input of OutgoingReaction (send a reaction)
// And it returns an output HandlerResult (A result.)
#[allow(unused)]
pub(crate) fn react(input: OutgoingReaction) -> Result<HandlerResult, extism_pdk::Error> {
    let res = unsafe { raw_imports::react(Json(input))? };

    let Json(res) = res;

    Ok(res)
}

// request
// It takes input of OutgoingRequest (An HTTP request)
// And it returns an output HandlerResult (A result.)
#[allow(unused)]
pub(crate) fn request(input: OutgoingRequest) -> Result<HandlerResult, extism_pdk::Error> {
    let res = unsafe { raw_imports::request(Json(input))? };

    let Json(res) = res;

    Ok(res)
}

// sendMessage
// It takes input of OutgoingMessage (An outgoing message)
// And it returns an output HandlerResult (A result.)
#[allow(unused)]
pub(crate) fn send_message(input: OutgoingMessage) -> Result<HandlerResult, extism_pdk::Error> {
    let res = unsafe { raw_imports::sendMessage(Json(input))? };

    let Json(res) = res;

    Ok(res)
}

// watchMessage
// It takes input of String (the id of a message to watch)
// And it returns an output HandlerResult (A result.)
#[allow(unused)]
pub(crate) fn watch_message(input: String) -> Result<HandlerResult, extism_pdk::Error> {
    let res = unsafe { raw_imports::watchMessage(input)? };

    let Json(res) = res;

    Ok(res)
}
